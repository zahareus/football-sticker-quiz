# Аналіз та покращення алгоритму підбору пар для Battle

## Проблема

Поточний алгоритм підбору пар (`get_battle_pair`) має наступні проблеми:

### 1. Нерівномірний розподіл показів

**Симптоми:**
- Велика кількість стікерів з початковим рейтингом 1500 (не показані жодного разу)
- Деякі стікери показані 10+ разів, в той час як інші 0 разів
- Поле `games` показує великий дисбаланс між стікерами

**Причина:**

Поточна формула ваги для вибору anchor стікера:
```sql
random() / sqrt(games + 1) DESC
```

Ця формула дає перевагу стікерам з меншою кількістю ігор, але недостатньо агресивно:
- `games=0`: вага = `random() / 1.0` = random()
- `games=99`: вага = `random() / 10.0`

Різниця лише в 10 разів, що недостатньо для гарантованого показу нових стікерів.

### 2. Жорстке виключення recent стікерів

**Проблема:**
```sql
WHERE id != ALL(v_recent_stickers)
```

Поточний алгоритм **повністю виключає** до 12 недавно показаних стікерів з вибірки. Це призводить до:

1. Якщо випадково декілька стікерів з `games=0` потрапили в recent список, вони не можуть бути обрані зовсім
2. Зменшується різноманітність можливих пар
3. Створюються "пули" стікерів, які показуються по черзі

### 3. Відсутність гарантії показу нових стікерів

Алгоритм не має механізму для **примусового** показу стікерів з `games=0`, що може призвести до ситуації, коли такі стікери довго чекають свого показу.

---

## Рішення

Новий алгоритм у файлі `002_improve_battle_pairing.sql` виправляє ці проблеми:

### 1. Експоненційна вага для стікерів з меншою кількістю ігор

**Нова формула:**
```sql
random() * power(0.5, games / 8.0)
```

**Як це працює:**
- `games=0`:  множник = 1.0 (повна вага)
- `games=8`:  множник = 0.5 (вага в 2 рази менша)
- `games=16`: множник = 0.25 (вага в 4 рази менша)
- `games=32`: множник = 0.0625 (вага в 16 разів менша)

Це створює **експоненційне** зростання переваги для стікерів з меншою кількістю ігор.

### 2. М'яка обробка recent стікерів

Замість повного виключення, **зменшуємо вагу на 80%**:

```sql
CASE WHEN id = ANY(v_recent_stickers) THEN 0.2 ELSE 1.0 END
```

**Переваги:**
- Recent стікери все ще можуть бути обрані (з 20% вагою)
- Це корисно, коли у нас мало стікерів або багато нових стікерів в recent списку
- Збільшується різноманітність пар

### 3. Гарантований показ нових стікерів

**З ймовірністю 40%** обов'язково обираємо стікер з `games=0` як anchor:

```sql
IF v_new_stickers_count > 0 AND random() < 0.4 THEN
    v_force_new_sticker := true;
END IF
```

**Додатково**, з ймовірністю 30% обираємо новий стікер як opponent (якщо anchor не новий):

```sql
IF v_new_stickers_count > 1 AND v_anchor.games > 0 AND random() < 0.3 THEN
    -- Select new sticker as opponent
END IF
```

**Результат:**
- Нові стікери гарантовано показуються швидко
- Уникаємо ситуації "два нових стікери проти один одного" (оскільки обидва не мають встановленого рейтингу)

### 4. Вага застосовується у всіх режимах відбору

У поточному алгоритмі weighted random використовується тільки для anchor. У новому алгоритмі вага застосовується **в усіх режимах**:

- Mode A (40%): Close rating - з вагою
- Mode B (40%): Random opponent - з вагою
- Mode C (20%): Extreme matchups - з вагою

Це гарантує, що навіть при специфічних режимах відбору нові стікери мають більшу ймовірність бути обраними.

---

## Застосування

### Крок 1: Аналіз поточної ситуації (опціонально)

Запустіть в Supabase SQL Editor:
```sql
-- Файл: analyze_sticker_stats.sql
```

Це покаже вам статистику:
- Скільки стікерів не показано жодного разу
- Розподіл кількості ігор
- Топ найбільш/найменш показаних стікерів

### Крок 2: Застосування міграції

Запустіть в Supabase SQL Editor:
```sql
-- Файл: supabase/migrations/002_improve_battle_pairing.sql
```

Це:
1. Видалить стару функцію `get_battle_pair`
2. Створить нову покращену версію
3. Надасть потрібні дозволи

### Крок 3: Тестування

Протестуйте функцію:
```sql
SELECT get_battle_pair('test_session_123');
```

Запустіть кілька разів і перевірте:
- Чи обираються стікери з `games=0`
- Чи варіюються пари
- Чи працює логіка recent стікерів

### Крок 4: Моніторинг

Через деякий час (наприклад, після 100+ голосів) знову запустіть `analyze_sticker_stats.sql` і перевірте:

- Чи зменшилася кількість стікерів з `games=0`
- Чи став розподіл більш рівномірним
- Чи зменшилося стандартне відхилення `games`

---

## Очікувані результати

Після застосування покращеного алгоритму:

1. **Швидкий показ нових стікерів**: Стікери з `games=0` будуть показані протягом перших 5-10 голосів
2. **Рівномірний розподіл**: Різниця між `min(games)` та `max(games)` буде меншою
3. **Менше стікерів з початковим рейтингом**: Кількість стікерів з `rating=1500` суттєво зменшиться
4. **Більша різноманітність пар**: Користувачі побачать більше різних стікерів

---

## Технічні деталі

### Параметри, які можна налаштувати

У файлі `002_improve_battle_pairing.sql` ви можете змінити:

1. **Ймовірність примусового вибору нового стікера** (зараз 40%):
   ```sql
   IF v_new_stickers_count > 0 AND random() < 0.4 THEN
   ```

2. **Швидкість зменшення ваги** (зараз ділення на 2 кожні 8 ігор):
   ```sql
   power(0.5, games / 8.0)
   ```
   - Менше число (наприклад, 6.0) = швидше зменшення, більша перевага новим
   - Більше число (наприклад, 12.0) = повільніше зменшення, менша перевага новим

3. **Вага recent стікерів** (зараз 20% від нормальної):
   ```sql
   CASE WHEN id = ANY(v_recent_stickers) THEN 0.2 ELSE 1.0 END
   ```

### Зворотна сумісність

- Функція має ту саму сигнатуру: `get_battle_pair(p_session_id TEXT)`
- Повертає той самий JSON формат
- Не потрібні зміни в клієнтському коді (battle.js)
- Працює з існуючою структурою таблиць

---

## Підсумок

Новий алгоритм вирішує проблему нерівномірного розподілу показів через:

1. ✅ Експоненційну вагу для стікерів з меншою кількістю ігор
2. ✅ М'яку (замість жорсткої) обробку recent стікерів
3. ✅ Гарантований показ нових стікерів з певною ймовірністю
4. ✅ Застосування ваги у всіх режимах відбору

Це має призвести до того, що всі стікери отримають покази більш рівномірно, а нові стікери швидко інтегруються в систему рейтингу.
